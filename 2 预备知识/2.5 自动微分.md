深度学习框架通过自动计算导数，即_自动微分_（automatic differentiation）来加快求导。

实际中，根据设计好的模型，系统会构建一个_计算图_（computational graph）， 来跟踪计算是哪些数据通过哪些操作组合起来产生输出。 

自动微分使系统能够随后反向传播梯度。 

这里，_反向传播_（backpropagate）意味着跟踪整个计算图，填充关于每个参数的偏导数。

## 1 一个简单的例子

![[Pasted image 20251026141545.png]]
注意，一个标量函数关于向量的梯度是向量，并且与具有相同的形状。
```python
x.requires_grad_(True)  # 等价于x=torch.arange(4.0,requires_grad=True)
x.grad  # 默认值是None
```

y = 2 * torch.dot(x, x)
y

y.backward()
x.grad

通过调用反向传播函数来自动计算`y`关于`x`每个分量的梯度，并打印这些梯度。

现在计算`x`的另一个函数。

在默认情况下，PyTorch会累积梯度，我们需要清除之前的值
x.grad.zero_()
y = x.sum()
y.backward()
x.grad

## 2 非标量变量的反向传播

当`y`不是标量时，向量`y`关于向量`x`的导数的最自然解释是一个矩阵。 对于高阶和高维的`y`和`x`，求导的结果可以是一个高阶张量。

当调用向量的反向计算时，我们通常会试图计算一批训练样本中每个组成部分的损失函数的导数。 这里，我们的目的不是计算微分矩阵，而是单独计算批量中每个样本的偏导数之和。

```python
# 对非标量调用backward需要传入一个gradient参数，该参数指定微分函数关于self的梯度。
# 本例只想求偏导数的和，所以传递一个1的梯度是合适的
x.grad.zero_()
y = x * x
# 等价于y.backward(torch.ones(len(x)))
y.sum().backward()
x.grad
```

> 就像你有10个同学分别给出对你作业的修改建议（单个样本的梯度），你不会逐条列出10份完整建议表（微分矩阵），而是把他们的意见综合起来，得到一个综合修改方向（梯度之和或平均）。


## 3 分离计算

构建计算图（记录运算关系）

只有标量能直接 backward()

梯度只对需要求导的变量有意义
只有 requires_grad=True 的张量才会有 .grad 属性。

> x.grad 表示当前损失函数对 x 的偏导（梯度）

有时，我们希望将某些计算移动到记录的计算图之外。 例如，假设`y`是作为`x`的函数计算的，而`z`则是作为`y`和`x`的函数计算的。 想象一下，我们想计算`z`关于`x`的梯度，但由于某种原因，希望将`y`视为一个常数， 并且只考虑到`x`在`y`被计算后发挥的作用。

这里可以分离`y`来返回一个新变量`u`，该变量与`y`具有相同的值， 但丢弃计算图中如何计算`y`的任何信息。 换句话说，梯度不会向后流经`u`到`x`。

因此，下面的反向传播函数计算`z=u*x`关于`x`的偏导数，同时将`u`作为常数处理， 而不是`z=x*x*x`关于`x`的偏导数。
```python
x.grad.zero_()
y = x * x
u = y.detach()
z = u * x

z.sum().backward()
x.grad == u
```
tensor([True, True, True, True])

## 4 Python控制流的梯度计算

使用自动微分的一个好处是： 即使构建函数的计算图需要通过Python控制流（例如，条件、循环或任意函数调用），我们仍然可以计算得到的变量的梯度。

> **PyTorch 的自动求导（autograd）能处理有循环、有条件判断的普通 Python 代码。**

```python
a = torch.randn(size=(), requires_grad=True)
d = f(a)
d.backward()
```

```python
a.grad == d / a
```

tensor(True)

## 5 小结

- 深度学习框架可以自动计算导数：我们首先将梯度附加到想要对其计算偏导数的变量上，然后记录目标值的计算，执行它的反向传播函数，并访问得到的梯度。

## 6 练习

![[Pasted image 20251026155448.png]]

### 1️⃣ 为什么计算二阶导数比一阶导数的开销更大？
答案：因为二阶导数要对“一阶导数的计算过程”再求一次导。  
解释：这意味着要重新构建并反向传播一张计算图，计算量和显存消耗更大。

### 2️⃣ 再次运行反向传播函数会发生什么？
答案：会报错。  
解释：第一次运行 backward() 后计算图默认被释放，如需再次运行需设置  
```python
y.backward(retain_graph=True)
```

### 3️⃣ 控制流例子中若 a 是向量或矩阵会怎样？
答案：仍然能求导。  
解释：PyTorch 会对每个元素分别计算偏导，此时 a.grad 的形状与 a 相同。

### 4️⃣ 控制流梯度示例

```python
def g(x):
    if x > 1:
        y = x * x
    else:
        y = 3 * x
    return y
```
若 $x=2$，执行分支为 $y=x^2$，

答案：$\frac{dy}{dx}=2x=4$。

解释：只对实际执行路径求导，未被执行的分支不参与梯度计算。

### 5
```python
import torch, matplotlib.pyplot as plt
x = torch.linspace(-2*torch.pi, 2*torch.pi, 200, requires_grad=True)
y = torch.sin(x)
y.backward(torch.ones_like(x))
plt.plot(x.detach(), y.detach(), label='sin(x)')
plt.plot(x.detach(), x.grad, label='cos(x)')
plt.legend(); plt.show()
```


## 答疑


1. 为什么叫“反向传播”？为什么不是“正向”？
因为在计算梯度时，我们需要用**链式法则**：
$$
\frac{dL}{dx} = \frac{dL}{dy} \cdot \frac{dy}{dx}
$$
而在神经网络或计算图里：
- 我们先“正向”计算出 y；
- 再“反向”从最终输出（loss）往前传递每一层的梯度。
这个**从输出往输入反传导数**的过程就叫“反向传播（backpropagation）”。

**为什么不正向算？**
因为正向需要重复计算很多中间量，代价太大；
反向传播能共享中间结果（比如保存的 y、x），效率更高。